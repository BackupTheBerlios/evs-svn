\section{Logical View}

\cite{zdun2008}

\subsection{Common}
\subsubsection{Marshaller}

The marshaller translates objects into sequences of bytes and vice versa.

\subsubsection{Interface Description}
The interface description is the source for generating the interface for client proxies and remote objects. For the purpose of defining such an interface description the syntax for a simple IDL (Interface Description Language) was created and a corresponding parser was developed. This syntax allows the definition of classes and exceptions in the following form:

\begin{code}
\begin{verbatim}
PACKAGE bla.bla.blub
CLASS Dummy[
Integer tada
void foo(integer a, integer b) THROWS dummyException, IOException
Integer bar() THROWS dummyException
blablablub(Integer c)
]
EXCEPTION DummyException[
Integer count
]
\end{verbatim}
\end{code}

The IDL-Parser \texttt{evs.idl.SimpleIDLParser} analyses the file and generates Client and Server Stubs for the specified application. A Code-Generator for Java was implemented in \texttt{evs.idl.JavaCodeGenerator}, which generates the following files based on the interface definition:

\begin{itemize}\itemsep0pt
\item An interface for the operations provided by the Remote Object
\item A ClientProxy implementing that interface for the client-side
\item An Invoker implementing that interface for the server-side
\item Custom-Type Exceptions
\end{itemize}

\subsubsection{Absolute Object Reference}

\subsubsection{Connection}

TCP connections are uniquely identified by the pair of communication end points.
TCP/IP end points are uniquely identified by their IP address and port number.

\subsection{Server}

\subsubsection{Remote Object}

\subsubsection{Invoker}

The invoker calls the marshaller to translate request messages to invocations.

\subsubsection{Server Request Handler}

The server request handler receives request messages and dispatches them to the invokers.
The server request handler sends response messages to the client request handlers.

\subsubsection{Server Protocol Plugin}

\subsection{Client}

\subsubsection{Client Protocol Plugin}

\subsubsection{Client Request Handler}

\subsubsection{Requestor}

\subsubsection{Client Proxy}

\subsection{Protocols}

\subsubsection{Communication Protocols}

\paragraph{Minimal Communication Protocol}

The minimal communication protocol has no protocol header and therefore transmits byte streams without interpreting them.
The marshalling protocol is determined by the communication end points, which process only single protocols.
The sender and receiver are determined by the communication end points.

\paragraph{Typed Communication Protocol}

The typed communication protocol prefixes the message body with a 4 byte header, which specifies the protocol of the message body.
The sender and receiver are determined by the communication end points.

\subsubsection{Marshalling Protocols}

\paragraph{Binary Serialization Protocol}

The invocation is analysed and serialized via reflection.

\paragraph{Java Serialization Protocol}

The invocation is serialized by the default Java object serialization.

\paragraph{Axi2 Java Web Service Protocol}

The marshaller translates invocations to SOAP messages and vice versa.

\subsection{Configuration}

\subsubsection{Properties}

peer.local.host.name\\
peer.local.ip.address\\
peer.local.port\\
