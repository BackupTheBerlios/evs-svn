package evs.example.server;

/* Automatically generated by EVS JavaCodeGenerator */

import java.util.HashMap;

import evs.comm.exception.IllegalMethodException;
import evs.comm.exception.IllegalObjectException;
import evs.comm.exception.RemotingException;
import evs.comm.impl.AInvoker;
import evs.comm.impl.Common;
import evs.comm.interfaces.IInterceptor;
import evs.comm.interfaces.IInvocationObject;

public class DummyInvoker extends AInvoker{

	static private final HashMap<String, Integer> operations = new HashMap<String, Integer>();

	static{
		operations.put("testCall", new java.lang.Integer(0));
		operations.put("getCounter", new java.lang.Integer(1));
	}

	public IInvocationObject invoke(IInvocationObject object) throws RemotingException{
		
		for(IInterceptor interceptor: Common.getServerInterceptors().getInterceptors()){
			interceptor.beforeInvocation(object);
		}
		
		Dummy localObject = (Dummy) Common.getObjectManager().invocationArrived(object.getObjectReference().getReference());
		if(localObject == null) throw new IllegalObjectException("Object " + object.getObjectReference().getReference().getClientDependent() + " not available");
		
		Integer index = (Integer) operations.get(object.getOperationName());
		if(index == null) throw new IllegalMethodException("Method + " + object.getOperationName() + " not supported");

		switch(index.intValue()){
			case 0:
				localObject.testCall((Integer) object.getArguments().get(0));
				break;
			case 1:
				Object returnValue = localObject.getCounter();
				object.setReturnParam(returnValue);
				break;
			default:
				throw new IllegalMethodException("Method + " + object.getOperationName() + " not supported");
		}

		Common.getObjectManager().invocationDone(object.getObjectReference().getReference(), localObject);
		
		return object;
	}
}