package evsbsp.server;

/* Automatically generated by EVS JavaCodeGenerator */

import java.util.HashMap;

import evs.core.AInvoker;
import evs.core.Common;
import evs.exception.IllegalMethodException;
import evs.exception.IllegalObjectException;
import evs.exception.RemotingException;
import evs.interfaces.IInterceptor;
import evs.interfaces.IInvocationObject;

public class DummyInvoker extends AInvoker{

	static private final HashMap<String, Integer> operations = new HashMap<String, Integer>();

	static{
		operations.put("testCall", new java.lang.Integer(0));
		operations.put("getCounter", new java.lang.Integer(1));
		operations.put("newInstance", new java.lang.Integer(2));
		operations.put("keepAlive", new java.lang.Integer(3));
		operations.put("destroy", new java.lang.Integer(4));
	}

	public IInvocationObject invoke(IInvocationObject object) throws RemotingException{
		
		for(IInterceptor interceptor: Common.getServerInterceptors().getInterceptors()){
			interceptor.beforeInvocation(object);
		}
		
		Dummy localObject = null;
		
		Integer index = (Integer) operations.get(object.getOperationName());
		if(index == null) throw new IllegalMethodException("Method + " + object.getOperationName() + " not supported");
		
		if(index < 2){
			localObject = (Dummy) Common.getObjectManager().invocationArrived(object.getObjectReference().getReference());
			if(localObject == null) throw new IllegalObjectException("Object " + object.getObjectReference().getReference().getClientDependent() + " not available");
		}


		switch(index.intValue()){
			case 0:
				localObject.testCall((Integer) object.getArguments().get(0));
				break;
			case 1:
				Object returnValue = localObject.getCounter();
				object.setReturnParam(returnValue);
				break;
			case 2:
				Integer id = Common.getObjectManager().newInstance(object.getObjectReference().getReference());
				object.setReturnParam(id.toString());
				return object;
			case 3:
				Common.getObjectManager().keepAlive(object.getObjectReference().getReference());
				return object;
			case 4:
				Common.getObjectManager().destroy(object.getObjectReference().getReference());
				return object;
			default:
				throw new IllegalMethodException("Method + " + object.getOperationName() + " not supported");
		}

		Common.getObjectManager().invocationDone(object.getObjectReference().getReference(), localObject);
		
		return object;
	}
}